# -*- coding: utf-8 -*-
"""machin. dog and cat

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ant9VA_3xIG9zWUsudieQqxE-dSqa2kP

![download.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAf4AAACMCAYAAACd8stbAAAgAElEQVR4Ae2dBZgV5ffH6W5suhUUJExUVBQBUUAlVVS6uwRRSkFFRSkTCzB/ii2YGKh0iZSJ3YnN+T+fc/fcfXf2brIo+/e8z7M7c2femu/Mvd9T75k84sURcAQcAUfAEXAE/jMI5PnPXKlfqCPgCDgCjoAj4AiIE78/BI6AI+AIOAKOwH8IASf+/9DN9kt1BBwBR8ARcASc+P0ZcAQcAUfAEXAE/kMIOPH/h262X6oj4Ag4Ao6AI+DE78+AI/D/DIHdu3cLf3ta6OPvv//e0268vSPgCOxjCDjx72M3xKfjCOQUAhD3rl275Msvv5Tt27fL2rVr5dVXX5UXXnhB/1588UXh75VXXtFz7777rnz11Vfy66+/5tQUvB9HwBHYBxFw4t8Hb4pPyRHIDAJRrf7333+XrVu3ytKlS+XOO++Um266Sa666ioZOXKk9OrVS3r27CkXX3yxXHDBBXLRRRfJJZdcEt/nfJ8+fWTEiBEybdo0mTVrlsyfP1+WLFki27ZtE/oOC5aA6Pjhed93BByBfRcBJ/599974zByBFAhAtFGy/fzzz1V7v+WWW+TKK6+U7t27K6lPmjRJbrvtNnnggQfk8ccfl6efflpefvllWb9+vbz33nvy0Ucf6d/bb78ta9askddee021/0cffVQWLlyoba+44grtiz6nTp0qjIGFAKtAWBLNKzzv+46AI7BvIeDEv2/dD5+NI5AQgZDwf/nlFyXqOXPmyJAhQ6Rr164yZcoUWbRokSxevFg2bdokP/74owoJ1OXPCvtYBTZv3iw7duyww/LTTz/Jt99+K3/++ae2++2331TLpx593nfffTJ58mQ5//zz1YIwb948nYO7BeIQ+o4jkGsQcOLPNbfKJ/pfRwBf/cMPPyyXX365kj1a+L333itvvPGGfP/996ngwZePpn/77bfLddddp3W+/vpr6dKlq8yaNVuwClxzzTVK9OvWrZNzzjlH/f109Nlnn8mTTz4pn376abzfb775RpYvXy533323CgEIHFgFHnnkEeGcF0fAEcgdCDjx54775LP8DyGAdh9G00PW999/vwwePFh99WjbL730kmrpBgsm/xkzZqg5n2OY+fHz//HHHxqsN3r0aOndu7dWHzduvKxbt15N/e3bn6Njffzxx3LhhRfKDz/8oHUg/OHDhwvHn3rqKbn55pttKN1iHcB1MHv2bI0dGDRokM6R41bCa7BjvnUEHIF/HwEn/n//HvgMHIEUCJhZH9J+7LHHZODAgRp4h+aOT56CKR5/PZo6BVN9p06d1CLAuW7dugnCgBX88ieeeKJs3LhRxo27TK677ga56aZZasanDpH9uA2sfPLJJ+rr5zPjtm7d2k7pltUCtgKAGIG5c+eqUDJ06FAVFJi7F0fAEdg3EXDi3zfvi8/qP4iAET6XDplOmDBBg+uIsIewOQ8hP//88/K///1P7rrrLiVbBAN87QTlEeD3888/S4sWLeSDDz5IgSKR/FgKLr/8Cpk580Zp27a9bNiwQevcc889Op41YPwHH3xQ/fw33HCDjkO/FNwA5557rtx4441WXS0LtOEYKwdwR5hQQqXw2uKNfMcRcAT+FQSc+P8V2H1QRyAlAkaMkCvL6NDY8Z8vW7ZMtfvvvvtOMPmz1A4Ct6A6tPt27dqpD3/nzp1K0BzD/47/3gqmezR6TPcDBw6SzZvfkeeee0HborkjNKCtW0GwePPNN2XVqlVqwr/00kvVgvDFF1/I+PHjpXnz5jof6tvc2WdezJm5cw3EIFhwIfXsz8bxrSPgCPzzCDjx//OY+4iOQEIESLIDwbKmfsGCBfGAOYi5X79+SqgIBh07dpQtW7bE+8AC0LlzZ/nrr7/U375ixQo936VLFw3Ee+utt5SAV69ereTdu3dfufPOu+Xrr79RzZ/4AQh9wIABKgA8++yzcscdd6hmTzwB448bN06XBmIFwAKBRm8FMo+u6yfYDysC1zJ27Nj4CoJQSLD2vnUEHIF/FgEn/n8Wbx/NEVAEopov6+N79OihJEnkPOfx0RNsR/IcSJvlexS0/unTp8eRxA2AwAD5Dhs2TPc5iR+eTH1o7StXrlTBgXX6jz66WBYvflweeeRRWbr0OfXJQ9Qs5aM+4+OjZ7XAZZddpnOBvEn4g/bO+AgAFLsO23Jsw4aNGn+AIELswJgxY1QAIBjQCue8OAKOwL+DgBP/v4O7j/ofRQCChKBD4kPjJpve9ddfr5H2QIMvnuV14TK5hx56SF5//XU116Phs4QPIiaynvr0zbp7tHfW8WP6RyhgfT+JfFi3H420pz2pfNHwmQd+enzzH374ofZtLgWEAI4hQLRs2VLTANsttGviM/vDho2QAQMG2mlNF3zttdeq6Z9rsAIG1PfiCDgC/ywCTvz/LN4+miMQJ19IGFM6Pnsi59HQCZxjzT1mf5bfsSzPCpH7EDQWALRvfPZPPPGEkjF1WEoHiaNl46PH1I72jnZOPYibRDzPPfecYP4ng58VBIWZM2cKFgFInqWArM9HS6cuY1MQDLA2hOv7IW8jcPo+66y2ak2gvh1HgOAauVau2QQQ29o8fOsIOAJ7HwEn/r2PsY/gCKRCgAA8CBTzPgQLAfKSHLRz8uOjiUPUROcjBFghap5IfOqgfUPY+PtJ1ENiHY7TjxG1tcNvf/bZZ2vqXdLz0hYhAAHBrArEDyAkYPKn0AdWAnL/0zcJfcj6ZwVSD4mbWAPmP2HCFZonwOoxPwQG6x+hhfcI2DhhH9bGt46AI7D3EHDi33vYes+OQEIE8J9fffXVqv2SHIfCi3Aw35OEJyy33nqrRt6jdRsBm5uANf2Y8DGfQ8hmlg/bsxIAzR+/PKl8owVCJvofwYBCrAHjRAt9Q+AIBrgEiBuwtfpYIFhaSD87d34sBA+yCuH9999X4eLII4/UTH9YNCikAEbggfytDzf7RxH3z47A3kPAiX/vYes9OwKpEEBLxieP1mukj6bMC3Ag77Zt22oSHhqamZzkONSHXCFZ/PiQOcl98OeHJdSeMdOT7Y8IfEz3LM+zYn3zmYA++kdIQPvHAmHCBefDPvlM0CF1mAMxBBSu5Y03lsvKlaukZcszldx5ORDuCt4OSB9o+JZUCNcDY3JtFOYTzkkP+j9HwBHYKwg48e8VWL1TRyAxApjMSXADcVLQuNGy0fgpaOWskcc3Hy1o0bTDRB/1sVPXyBNNmxfqMBYJf6ygaT/zzDNx0761YctyPQQACn560871QNI/69+OMQe0f94fYO8KQIgZP/4yJXj6syBE2iCktG/fXlcX8JlrwefP0kWK9e8CgMLh/xyBvYaAE/9eg9Y7dgRiCBiR4X+H6CBkNGpIn0C+MMMdLRAEzjjjDPW/mykc0zpWAdqEJaqNMxaEjHCAC4AxeVkPZnoCB/Hv49dnFYD59ukPy4AJG5j6ExF/OG64j8uBubHk0K6VAEPiE1iFQEHT510ARPcjgBCECAZYIjjOHClcT/Sa9IT/cwQcgRxDwIk/x6D0jhyB1AgYEb7zzjvq12bJHgF5mOzx8xNAt2vXr7J27boUWjzpeiFv6mEyZ9+0agiTv0Q+fY5bgUB5ox8v2CHbHqSLIEBf/fv3l0GDBut6frR0XshDgCBCA5H9YT/WX7i168KiQPwBKwrQ/jH50xbLAtdAIVvgWWedpaZ9PjMG7gdM/wQxIvz07NkznuTHiT9E2vcdgZxHwIk/5zH1Hh0BRcAIDKIfMWKEJtYhUp/COV6S063bJdKpUxfNm9+hQydZsyamCdMGYsevHw22g3Rpz7I4ovPDwjkjZTuO6Z40wPwhCJB5D+Lv2LGzDB8+Mp4lEI1/4sSJcVN8tB/rLxyDeAUCB60gWDBnLBWQOqmA27Rpo2NgbaB/MCDHgOHDPq6GUaNGpVqNYP361hFwBHIOASf+nMPSe3IEUiBgxEnGvb59+8ZJmuOQHtr8a6+9LqtXr1Gyxid+5513aR9o0GY+54C1sX22vDwnTIijDSP/sBJAvpjajWipwpr6Ro0a65v6IPytW2MpgIkPMDO/zT/skmN2HPcBSxKjcyBlMP2TdRC3BemGKczF4gj4jNBC4B8FFwYYcc1eHAFHYO8i4MS/d/H13v/jCGAGZ+kay+CMMNmGJIxmDPERpU/EPr531uuzTzGytfYcQ3tG24YoIdi0CmZ3NHzM6RTrAzP7woX3yW233S6XTbhMEwOl1Uei4wgHuAQgcnz20cLcST7EteHmYAUAMQBWaIP5nxTDxBtQwAisrF6IkbXzrSPgCOw5Ak78e46h9+AIxBEwkuYApEd2vUmTJqlf3ypZHdsSrc+adszkkDiEaaQPcRtZ25Z+yLLHmn/88lgOEhWrjyBBXeZDwdROoN/LLy+TZ55ZInPnzJX7Ft6n52iTGcJF8MCfD0kjACQqRv64LFhaiBXgo48+UpcH6YiN4FkVwJywCOD7xy3CXG3+ifr2Y46AI5B9BJz4s4+dt3QEUiEAaRpxEuzWp08ffWEN5MeadTLhhcXq2jHIkYj3sECAURIkGp6gPfz36Wn81g9xAvyxdA4hgKV1fH7wwYdk+lVXy8J7F2nVcP7WNrqlDgGBjI3gQQR/WgVLBnOlrF+/Xpo2bap+fhNCOM5rfAk4pOAmIP6AlQeURNeuJ/yfI+AIZBsBJ/5sQ+cNHYHUCBhB41MneY0lqCHdLUvbOE8kP2l1rVgbW2bHcY598MEH8Uh+Pls9NHxS45Jrn7Xw0SV+1q/1w5Z0ufjkSfdLxD2FOfB63vHjJkjvnn00Ol9PZOIfxM8cEG6I2k9UbL4s1WNlAgF/BAKSKCgsrG7AbUHBwoE1A+ws2Y/1E7bxfUfAEcg+Ak782cfOWzoCaSKA75218fYiHEz5kD8aNznzW7durWRn+eoRCjB5U9Co0aSJgMfsHc3Oh+BgKXaJCzDiD4UD+uFz1KIAsULCFsC3adPbMmrkGOnUobN07NRJE/9gxic2AeuEkW7YN0IE1gbI2eZh9RIBwjkCAMlXwLWAAUIHSwHB5eijj1YXAG4AghrBbOjQoXFLQaI+/Zgj4AhkHwEn/uxj5y0dgRQIGPlBaN27d1dfvRE7mfkgSoLX8HdDcFOnTlWtnn38+hA6hSV3mMchS0z/rP3HLE/0PRo7rgC0Yvpha/EAUZK3yfFCIAQLtHSEC96+R4F8n3jiSZk8aapMumKyauME2GFpwOQ+ZcqUFEF/dn0IBGjuxC6EQoeNF25tTixPRFggngEsaE8GQxIa4QIgSBBhyCwkJDkiyp81/xQbO+zb9x0BRyB7CDjxZw83b+UIpIkAGi0JcUJzflgZYcAi3SFE6pP9jgLB4f/m5TsEzfGHKZwUvAT/kRsf8ocoEQQgU7R+a6s7QX59iJe+aEsAHeOyxI4X6kCyy5e/Iffes1B9/O+9G3tNL0SMpQEfPqsBonEJWA1Gjx4t9957r5rmmXNaxMz4do50xET3U4hLwJRPgB9jdenSRecIZtRnTAIjmbsXR8ARyFkEnPhzFk/v7T+IgBEbl04EPevWIVV82mjx0ah7NOpLL71UyQ0yDKPirS9M4pjk8X1DspjE0cZ5uQ1uAILhOMbb+6x/2oZ/jE+bsWPHal0i5q+44gpdQkcfmOwfevhhmT17juYSwIKAIMISO3M7YF2gD4rNDVP8oEGDsuSDt7ZcKxaKr776SjP5tWvXTsfC74/wY+8sQDji+gj0w0oQjq8f/J8j4AhkGwEn/mxD5w0dgRgCRmp8QpvGP20aPNrs+eefr1npBgwYoOZxTOj40SmY+CHBsKBRW0EAQLNHuyaYjv75QzM2f7lFyJt2beSPJYG54C4giQ9BdmjSZn4nmBBLAmb9N996U6PzEUSYs60U4I2BBPBRrB3r7jHV40LIbDGMcGPccccdKqywxa9PIp/TTjtNWOJHXIRl/sOywWdL+mPjZ3ZMr+cIOAKJEXDiT4yLH3UEMo2AkRrEREAeefHRnCkEyfEZ4kbjRuMlWx1mdwgPvzvF+rD98LNWENFguO3bt6tPHB84pEnAHBo59fkzckQ4YCzWxtMG7T4sCAJYElgVQDvcBQgQLK1DULD5o4HbUjtrT+pfshFSGC/RXK2ubW1+fOaaLdUwmQJPOeUUxYfx0fSxPPDHnC+77DK58sordZzMjmVj+tYRcAQSI+DEnxgXP+oIZBoBIz5M+Lxjnuh9CMx842jnY8aMEd6wR4HAiKqHQAnso1gf+iH4x3Hq8xcW/OMEADIOZnvGtELflk0PqwB+ddPgqcM5Aus4jgaOAIEAQIFwScxjb+4jJsDW1HOefATk1Le1+9F523zZRs/pACJq4eDaOc9YCEVh4VpxYdh1gCmCkhdHwBHIGQSc+HMGR+/lP4yAkTLr49HuWdeOpkzUvhE7pn/ejmcmfoL0CJ6jpEeSIaxGpLZFO7fX2ULmCAAUXnqDRo6pHLM5WrUVIvotv4CZ0Jm3JQ3CjM8KAiN+hJUwFz+BfwTdYUmg2Fysf9wU5qpI77oINgQjgvvoMyzMH7cIsQsITWj9zIkSHS9s5/uOgCOQOQSc+DOHk9dyBNJFAEK66qqrlPjRVCFQW8NvDTFvQ2IQGtHqRsgZkVl4nn37TPAeWrsluoH8IVQCADGnk6PfrAzMAZIlvgBhADcApnX6oj6mfeaNMALJYimgIKiYO4LPnOPlQFgaKDYX/ZD0Gd8/41r/di7ccu0IFFgccFvwGdP+m2++Kaeffrq+q4D6zIvX+5JtkBIdL+zT9x0BRyBzCDjxZw4nr+UIpIsA5Ms75W25Gqb9Xr16aVAdGfMgLCwDBPJBqkTNm6Ug3Y4zOMk6etP0qYr5n4BBCpq8ETSaPsF+mPSZI9YAChHzmNspaPkQO1YEWz9PrIAFKlKHlwcRAxAtXIuRMgGCBA2mZ56nPsIPY+JOIP6hW7du0rx58zjJI4gwf4IAwTKa8S86B//sCDgCmUPAiT9zOHktRyBdBCBgItAJpIPcIVg0aUz/Xbt2Vd8/75znHGZ1NNs9KZAsf5jV8ZFb2lx88EThMw9zAzAeJItrAO2aeRlJo5nzmcKLe9Du8fPj96cgCHCcgnkfM78l7dGDSf9sPhA1qwTw4SPwpFdYrUBdCgIIWj9mfq6FObFkECEJlwD769aldAmk17efcwQcgbQRcOJPGxs/4whkGgGi4slkh+maNLaY0q0QWAehEkWP6ZooeSNWq5PVrREt7dDIIXsjcwgUjZ05QOKY1CFPhBHqhWMzb8vkRzAiGj7mfcsGyLXYOnqEFYQXhItEBSGEoDwsDiQWyqhgEWA+uD5wS5iV5IILLtAESCQZos7nn38mkydPkSefjMUwZNSvn3cEHIH0EXDiTx8fP+sIZAoBTOCYtyF2tFTM3dHCOQQDlt+ZCT5aJ7ufMeuT8McKxE1wIRYHxiTqH5eA+etNSMDkT5IgtHlWJRCtjyCANk4d2th6fbRwCDrqorC+EHBY3492jvke0sY8z3mrw/xs3xIM4dsnOyFET9CjBURSF5xwB0ycOElmz55rl+dbR8AR2AMEnPj3ADxv6giAAMRIil7S26L14gMnYh6tGz+1FQiPhDiY3ClGgHZ+T7aQMeSOBg95swSPfSLmGY9jCAfmu2ds/iBWiB8XAHNGqyc3AHUpaPwWpY8gYVn8onPFooAvHitDixYtNICQLIG2WiC8VhubPpgbAgLzNJdCtG+ujcDJUaPGajbE6Hn/7Ag4AllDwIk/a3h5bUcgFQIQFsFnmNIxW5P5jkA1XkDDH0IBmjcmdjRaS14TkmGqTrNwICRS/Or0j9aMjx8fOgIAmn1oEbCxIWbInRUIzJuEQ2j+lhcAAQDNHCsG6XPNb2/tbZq4FB5/7HF54IEHNciRuAMsBwgN0brWhi1zxVXB+KToxToRXo/VJTCxd+++et6O+dYRcASyh4ATf/Zw81aOQBwBzNqYt1kuh3aKls+WSH80fMzrtr6f5XJoxzlZIErGCwmWdwRAlmjyuBjQxNGsowXSt2Q8aPT493m7oOXqh9C5HqwBLAVEsKHYWMQFIGCsWrVa7l/0gIwYPlLe2bxZx7R6Vjc6Np/BjgBCLA9o/9EMg9Z2+fI3ZeDAwXHs7HiiPv2YI+AIpI+AE3/6+PhZRyBDBNBaCdxDUyZqnyV15qeG1FguR4AcLgHM4WjPlL1BXtYn45EzACsD5GyZ/BAQrFCXuTFXfPGsSiBhjgUGUg8yZj0+rgNcAmH5+JNP1C9PXoC1a9fJeed2lJkzb9TAPlsuGNZPtM9YLC9EuEDwQFhJlGJ4x453ZcSIUfoyIfqx60zUpx9zBByB9BFw4k8fHz/rCGSIAFoyOfohMXzkFkDHsbPOOktmzpypxAvxIxSgge+tYoSIeR8LBIWlfJZMyM5znPlggWD5HJYBmxuWCiwB1CURUSy4bmJ8vT/WBMs8yHmC/ojkv+6667UOn+k7M4WgQns3ADhiYcDkz6oA3Ay4HnA1IFSRyGf58te12/A6MjOO13EEHIFkBJz4k7HwPUcgWwiwBM6W8hFNj1mdQL+TTz457pNGk8WEjuZs5vJsDZZOIyNDBBBLs4v2zHwSFfzpmPmvv/56XXePv5+leiwHxNQP4XJtmONZv099rANE9iPMrF+/QQUa4huwKEDauDZsHonGjB5DQGBJH8KFFeY0a9Zsad++vbRq1UpdJsRRTJo0Ucewer51BByB7CHgxJ893LyVIxBHAK0Z/zeaMr5q1ukT0Y6WSsGUDfFjfkeLzQoxxgfJxI71+/rrr6uJniYIABB3WKweiXjQ1NG4IW60d+ZvrgGIHusFgX6ssSdQDyECnz4ujPsXPSjjx10mc+fOVTP9M88+Gx/GxogfSGMH14O5G9DuESgg/O7de8iTTya/LAjixxWwZEksZ38a3flhR8ARyAQCTvyZAMmrOALpIfDSSzGNn6xz0QKRkh0PkoW8LFo+Wi8nPhvZ4m7gD/++aft2LhwHcz7auwXzmQ8fKwGET7Q9ZnsEAwQElvlxHILu32+AjBg2QhYsWCSPPhoTGn777VfZnTRAovHCscN9rArEEcybN09XBNiqh7AOVgzW+psbJTzn+46AI5A1BJz4s4aX13YEUiGApnzFFRM13SwnSWSD1myF98mjeWMm35vEb+MRPMh4WBrM6mBEbFv89LgdIH+0bhIO4Z6gEJiHRg/R83Icths2rJcVK1bK/fc/qNc6efJUXR6IFk7iHes3DB60+WS0xYJAUGQiwcnaIpyQHMiJ3xDxrSOQfQSc+LOPnbd0BBQByGjKlKny5ZdfKbmzhr9Dhw4awd+vXz/p06ePLlPDjx2+UGdvwUfwIFq6LRs0UmY828cigBBir+bFN29L+LBQIBBwjpz7WC0IFOTzoEFD5ZFHFqt/H5cCZv5169Zqv5C+9Z/Za6M+mCAssWX9P8l8sDoQ+Ee8AYGJrDqA+Hn7oBdHwBHYMwSc+PcMP2/tCKgWCvF/++13mjDHls5hRp8+fboiBIlBXiT5gUj3ZoE4TTOGWEMyZh+CZh5YA1iuR0AfMQgs5aOQeMfiBHgFL5aKUaNGyYABA2TKlCvl+utvlLvuulstCpyj0Gd2iJ9AR6wTWCDICoiVguA+BBMsEE2bNtV9hKbJkydpHALjhdekE/B/joAjkGkEnPgzDZVXdAQSI8AytEmTpsinn36uJnMC1PCJk7GPtfRkvCOPPwSLRgvJ7c1CsJy9eMcIkq3tk30P3z/BemjxaNGY9q0gDNA+loVwpAwfPkIuv3xiPI/+9u3b9GU8uAHClMTWPitbNH2wYhuudmB54TnnnKPCAPMk+RArJ8DaiyPgCOwZAk78e4aft3YEVMsfO/ZSJX58+wMHDlRtlWQ9RPgvXLhQtVqIDZLDn703CwF5BOBRjOxD4kfDNu0eAQCSDUkXzZs1/Sy169ixozRpcozMn3+X3HHHfE3iQ3tSAVsbGyMr12RtiEfgjX5mBeEz7pHevfukyDS4Y8d7Mnr0GFm5clWK68rKmF7XEXAEYgg48fuT4AjsIQIExg0aNFg2bXo74Utk0LAx+6MdQ7SWTGcPh02zOf56EviEBTM8hUA9gvqsIJiQMIdiZEywIssTWYnQpUtXueSS7jJ16lWyYMFCFWIQZKxYG/uc1S2Cks2V7VFHHaXWEUvdy5JCLCVr166XQYOGyObNKZcmZnU8r+8IOAIiTvz+FDgCe4gA0ei9e/eOvwSH5WiQPeZp/NWY9iFYAtUgU3tjXXTYqI+cuIDsaNVk4jMfv40BQdMXrgaWxlkhABD/vpaktXiY/yH/ObPnyPRp10iPHj3ibTgXvuzH+snuFjxs+R4CBe4DAgvZv/baa2XYsGHy448/yOLFj0mfPn3ls88+z+5Q3s4RcASSEHDi90fBEdhDBNBOMe+zDp5sd/jzIV/WpxupsiYebRsTO4FzlFBbZt8+s6YdgYHIfMzuoYUgrJfWtMkeaK/VDeuQWc8EAhuL81ghPv8imVAZG00cwp8yaYqmzyUOYPny5So4YDHI6K174bjp7YMFmGClICjRCvMjIRLz/fXXXZrYZ+jQ4ar9Wx3fOgKOQPYQcOLPHm7eyhFIgQDaKeZxSBuSRLtHkx07dqwmnjnzzDPVb04QGz74RAWhgWVzvPQGvzepbIlynzNnjraBCDNT0OjJJhgKCZjM8dubCT3shwj6UIvHf4+Q0KZNG/n8s880qt7y5kPECAost9vTwvww72MR4ZpJcdy3b1/Fi/ljSWElBHOePHmK3HDDzD0d0ts7Ao6AuKnfHwJHIEcQQDOH+EnLS2AdRM/6/csvv1zX87Nmnsh5yB0ChogpRs4Q6aJFizRvPoQPIbIskD9IGfLHooAJPqOX/LDEDoIOXQeQNRaHRIU5YVo3wWLtmrUyb+7NctFFFynpmlCAZs6KAfomrmFPC5kMEWy4HrZYNhAwyIPAighecIRr4ZtvvjXKxyYAACAASURBVBaSIJE/wIsj4AjsOQKu8e85ht6DI6Ba8ciRI1XTh9DszXiJoNE89/ffr+QJGfOZNeuY9nEJ0BbhAP831gFIGwsCpEuWPM5Rx+IFiBmwP8zlLMezXAKMD6ETiR8KAjYvC/qjfTyBz4rVcu01M6Rt27a6hh8yxgJAHbLsIYRg9mfuNm5WtwgOxD2wPM+EHuZEEh+ul4KwRJzEhx9+ICNGjJC33lpp0/atI+AI7AECTvx7AJ43dQQMgZ07P5Lu3bsrUUOmBKjhaydf/s6dHyuBcpwlcpiwx48frxo8Jn3ejodWTVwAAX2YuSFSCgF59lpdBAoIk5z2ZMzj1bXRP/ojQO6WW26xqamGjqWAgoUhLPYZnz1WBiLon1v6vAwaOFg6deykwgACCUvs0LrJS4Bbg6WKzIPxmANbxrTPNi+ORY/zmbZggOUD9wdjkKQHgcKEAa4RvBBILr74EsUnnLvvOwKOQPYQcOLPHm7eyhFIgQDr0CFFcvZDVhAfxIUG+9xzzyux89Y5tFzIlnOYsTGbQ3Zo6vyhUUN05KanICwQM4AWjC+eoDvetke/BMYRQEgwHho5f/RJ8B1augXgkaXP+ksx6cgHhBXiA1jXf8kll6jQgsUBKwNzxJLAeMQuUBeXBuPwmXqWBph5oa2z5Tzz4zptrgghWCQQeJgjbcOVBkyLOAPaIYjEcL1CsYhM2T86Ao5ANhBw4s8GaN7EEQgRMK0ZwoX4P/popyakseMEpxEhz9I0S96DqR5CxrQPwUGskDMmfbRpiwFgHEgUgYB+WH4HwfIiHcuwR5Y9PkPG9AP5YyWg4L+HZLEkZFQQMIgPINAOrZ5igghCCYIF43AMsmfeEDQxCUTlY7VgfgglLGdk3lwn/TIn6ts5Yh/og+A9iP3GG29USwfaf1gw9U+cODG+1t8wDev4viPgCGQNASf+rOHltR2BVAgYGWHa79Onn7z00jKtg7YOcXXs2Cmes98axyLVJ6t/G80YosaHj/ZLEB/kikYNyePTRwvnGOfR/hEMIHrO84efnOP0tXHjRk0YxFgQP4IBqw0SFZs784Go0cCxVjAehXnRJ1YGCNxe9YvAghbPNeNaIECPAEEEDAQAzPa2FJHrQkDAhM8YWC3I/U9CI+bFHBA4OM+4ZDe0dxpgHSBHAoKFF0fAEcgZBJz4cwZH78URUH/8iBGjZOrUK+Xvv3crMTZrdqqmug3hgdzQ/DGDY/onuA+/Nxo1WjAaOuZ+CBMShdAhWd6ax3Ei4KkHEUOWtENIIDYA4YBj+Not+Q/kbwQfzoN9O44mz1gUNHA0dApjI2wwNv1D4GyxLDAnPiMc0B5tnnlxnMBD5m/zRNvnDysF86fPsGApQMBhJQHZ+xAimD8rJUaPHh2/lrCN7zsCjkD2EHDizx5u3soRiCMAeRqBPv74E/pSGwL1iHqH5KygeQ8aNEhOO+00XZZHXADpck2rxwcOwbKsz96WBwHzalzIlHoQP8QOUUKq1GMcNGPOmYkdU7q5FWxuNo9wa+cgfbR3rBRXX3113NXAuAgTCCiY7SF8iB6rAvPFvWFpdxFkCD7kGASPMACBIwTQznL849tH08eKcNVVV+nafV5kRPAgY9mLf9DyWSmBQEGxuYbz931HwBHIOgJO/FnHzFs4AikQCAkJwu/Vq5cSHpUwwaOZExXfqVMnJXGIDd82Gi3aOoSJ2R7fPil1+YOEKSS3gWDxuyMAQJ4QIlH/CAD44tmaiwAhAOJl+RuCASWcnx4I/nEOAYQ5EJTIeLQ3awFjY55nuSHj8JmIfPrmOHOF4BEMEHKYF+8lgKwhe17ry/all16WhQsXycyZN+o1MwXqdu3aVfGyVQw2NQQQLADkQmA1AyW967B2vnUEHIGMEXDizxgjr+EIZAoBIyaID/M0yXwg4hYtWqjvGmKlQHJouGjntCGwDQJH2ye4j4h/C+6DlNH0EQzQ4Flyh1ZMICCBcLgNIGssAJA//WFZgDQh6cwUlhcSV0D54IMPUpjh8e/TN5YFCJjoe0z4zAsBBDcFBa0ewYDx8c8juODvxwpB/MAXX3wpt956u9x8861aHwGGoEAK8QJYBnB3cD34+3lLH9o+QoYXR8ARyFkEnPhzFk/v7T+MAFoqBUJHU0UjRnOGOCkQIWZ8zPBk9oOwKVgFSFULybKP+d+y6OGf5zgaNMcgfsz6WAwwl6NxQ8Jk1UNrp2BFgJAxt9uc9EQa/6g/ZswYPYvQYL5+DkDmCAMQM4IHAomNQ6Y9rBkUTPwIKBQEEDBgfsQrMAdyGQwbNlyDAzkHDmzDQgwAKY65ZqwOWE7Aw4sj4AjkLAJO/DmLp/f2H0bANH62aPCXXnqpRrfbun6i3/GTowVPmzZNkTIrABHwnIfkSWaDxkuBNAncgwghZQu2gyQhbLRkLAUQPaZ2lt1hdscPj0bNOvhosXnaccibSHo0bYQFC+zjPFYDhA7cEAgcnEPYsJwD7KPtMy9IHgsHLgn2CfxDg8ctQLAhghAFIYJ6XBtzZZkjAYMU5otVgah/YgG8OAKOQM4j4MSf85h6j/9hBEzDRpu9+OKLlYDRyAlcwxdOGTp0aJwEIUx7gx/meYLp0LgREHAVYNKHmCF39iFICB9SRYCAjPGhQ8gWbY8QgKYO2aKtp1dwF9A/7REsEDzCNvTJfDhHPUicOTI/NHyEAuYAqXOOcXEFcF0ILNRjHgglYMPyRuoRvd+u3TlywQUXqvBC9D7xERTiGdD2CRqkRAUVPej/HAFHINsIOPFnGzpv6AikRgCSMqLCZA/JY4anIACgVZPMB18+pIllAO2Ygi8cAoREERzwk2NChzyJosdlALHSDr84mjaaNwIFW7Ro9okhoC3auJnfbU46UPAPjR5BAtcBZA2Jh8l+8NdzjP7C/pkPf9FjjM8x5sx8ERZIwENAI0LFqaeeqi/jwWWwYsXKOFZcM64M3AesfCCXACXEM5i27zoCjsAeIODEvwfgeVNHIIpASFQQGb7+mTNnasQ8dSFR3jqHad3WsqMFQ+YIBRAiAgPEickbIkQDR1BgH4EAwqcNf5yz8+EW7Zl4ADOhmyWCOTBHEvWgUWOKxxfPZ8iXOYXuAY4xFwIAmQN/No7t2xzCLdeOlYKgQYQKCnPnc6tWrdRqoAdF1BrAuLg9WAVAvEO4FDEtocXa+9YRcASyhoATf9bw8tqOQKYQMLKC0DD5o/lS8ON369ZNiZTPaPuYwvHHE91P5Dzr24lmZ59+CBC0PwLfsBywzegPFwDavBUImNUBmO75I64AsrbCXJmHzZ0tPn/mkdFYdp550o42XAPCCsIMMQ0mhOBWaN26tWLBObL8UcCIdwRY8KDNw+bnW0fAEcgZBJz4cwZH78URSIEApMUfJE0UP++XNy0dEzjn8Onj36cOBTM5pn4KpnzM3fj1s1sgbczrFMbGysAx+kSjRsunmDUA7Z86YaG+aezh8fT2SevL3HFxEEOAzx4BA5K3wvjnn3++LmtkHlgPcItw/U74hpJvHYG9g4AT/97B1Xt1BOIEhpkckz/+fEievPaQHEQbFkj2wgsvjJva0ZYhUAQCKyZQZIYcMfXj74dYETAg17BE+2KFAHEBYWH1QGh2D89F23MO/z792FjEKOCzR9ggDgFhB6GGgmBAffCYPn26JjmKvqUvHM/3HQFHIGcQcOLPGRy9F0cgXQTw7WPih1ghf3zntmSPhgTKkeiHiHiKETtaMhozkfSmmUPkdj69QQnMw7pAFL2Zz9Nri6kf4YO+qcc8aZce8VOPwpbVBBC71ec4feDCIG8BWfp44Q5CkAkG1EEAAhtcABS7Tv3g/xwBRyDHEXDiz3FIvUNHIIZAlJxZ384yNiNhzlu0O/n78blTID7OGQHiP0d7hyBD03+0/yju+PfNp0+wnfUdrWefcQtglcDXjhCAEMIyRLR2SjheuI9Fg7kRN8BcKSZgWD0EGMvBT78EDFIYB7++WRq4ZmurFfyfI+AI5DgCTvw5Dql36AgkRgBCw6SNxsuyPAqa/3HHHacEba2MLO2zbTGLo1GTstcS/1DX6tuW+uxjQsdVQPKfzBSi7gnuox05BMgsiKUCK0CiQvQ/lggsEiYcUC+tObFMkOREzAdLwGuvvKYWgGuuuUbJPto20Zh+zBFwBPYcASf+PcfQe3AEMkQA0qdApuPHj5fBgwerCZ7PkH9mC2SLFk9CHJL4mIZNe7MU2D5bluxBzpkpRNezrDAsLMkzIcWOE7nPigHmgHWAz5RwfKsbbhFWyAcA6a9auVoG9hskl0+4XPMXWPuwvu87Ao7A3kHAiX/v4Oq9OgIpEAi1YMze5KQfOHCgkj8VQ209RcPgQ1iHPjD/k/IWjTxMuhM00dwAmSV+2kHmLCe0QvY9BAwKVgDcB6TcxURvy/A4h2CTnok+nPuqVatl8OChMmrkGPn2m2+17/TaagX/5wg4AjmGgBN/jkHpHTkCGSNgfnt87rwYB80/1KhDASGt3kISJZAOnzm5+SFjggRZQodWTWEcWz/P57Bt+BniJS0vxM+SPkvig8ZPnn7iEohBwNqQleV9XK9dM2MTwDdgwCAZNnx4PLjRzuuE/Z8j4AjsdQSc+Pc6xD6AI5CMAORnRAdp8yIfMtVh7jezfZSck1sn74X9cBRzO8vlyBdA6l1S9WIJwH/O2ni0duvXxqcd+xyH6CF3/ng5Dpo+BaGEpEO4DCyugOO0sf60YoJ/nEegoCCIPPXE09KrR2+ZMOEKtURw3MZP0NwPOQKOwF5CwIl/LwHr3ToCaSEAIRr5op0T8EdkO2vtMadnt0D0LN2jQNSQPlkBOYZgQeQ97wNIVMi0h7ZPACFzYC0+/fEioKjFIDOkH45BKuIFCxZK94t7yIxrrou/jjhq3s9IkAj79H1HwBHIPgJO/NnHzls6AnuEgJE/BMhSP5L3oG2H76APyTE9YiRRz4QJE9Rcb4F3/fr1k0mTJsnkyZN1yxr6ESNGyKJFizSjH1YAEvQQld+pUycZN25c/HrIAYCmT/DeyJEjtV78ZDo7XJNdF9W2bdsuM2ZcL926XSx33Xln/Fx615JO937KEXAEcgABJ/4cANG7cASyi4CZwmlPAhzM/pAzS/Z4eU5Y0iNLzPto56yPx0zPi3wgdv44xpYld6zVZ4keb+XDX0+wHvv43gna4zzCwNVXX63naItvn5frZKbYHJk7loKhQ4dJv34DdExrHwoGdsy3joAj8M8h4MT/z2HtIzkCqRCABEOtnjS9vMYW0/+cOXNSaP80NmINO8J/jhk/rcj+sG56+/j5CRLERWBpdanPcSwSabkJon2SLRBBgWRFWBwsSx9zD6812s4/OwKOwD+DgBP/P4Ozj+IIZBoBiJwkN/3799c89+xHM/YhMECk/LGPP37WrFm6xI+APD7zR7AeGfWI+Le38qW1ZXUAbwskHgATP2v6cQMgiLBvwYd2ITYH+8wcsToMHDhI544VIrRoWD3fOgKOwL+LgBP/v4u/j+4IpInAxx9/rO+n79Gjh/rZIWSC8MISki++ffzyuAz4w4RvmfdMEEhvi9kfMz/trA9S+LLMj2KCBtuwME/mhouiZ8+eMnPmjSkElbCu7zsCjsC/j4AT/79/D3wGjkAqBCB0K/a6XoLzhg0bplo5SXYsY57Vw68OARNFT4IfAv7w7bMWPzN/RP9TD+ECtwHjppXu17LwEQRILgLSELM6gTwCVtISFOy8bx0BR+DfQcCJ/9/B3Ud1BDJEwIjTKrJOn5fm8EpfNOu5c+eqhs677nEP8GfaOQR8ww036Jp+zO/hH2QefrZ9zPxYDAgspCBcoP1b+f33P+T99z+QZcteldmz50iPHj1VEEmL8K2dbx0BR2DfQsCJf9+6Hz4bRyBDBAiWY839qFGjZMiQIdKrVy8VAoii5zipdPHzmxCQYYdBBYQLrAYU9gn2Q/NftuwVDTbs3buPptsl5TBjWeAe9aOCStCt7zoCjsA+hIAT/z50M3wqjkBaCECqofmfekTbs2yPN96NHj1a/wYMGKCmd4iZwDxM95j8IfGtW7cKr9Al5S7uAP7IHvjRRx/py3OwEqD9z5s3T1/sw/p/IvMHDRqkQgZ9kr6X/qJuBuYWxhukdR1+3BFwBP59BJz4//174DNwBPYYAYQASJ0X8rCUjmQ+/F1++eX6QiD88OQIwDpA1P3YseP1r3//QdKzZ2/p33+AWg9IITxx4iRNJcxbBHmtL5YEhIMwZe8eT9g7cAQcgX8NASf+fw16H9gRyBkEsAZEC9o3Jv8PP/xQ1+QTrY9v/4475su8eTfLvHm3JP3dLHfeebcsXvyYxgvg14fksQpELQzRMfyzI+AI5E4EnPhz533zWTsCcQTMDbA3fOzWp23jg/qOI+AI5FoEnPhz7a3ziTsCjoAj4Ag4AllHwIk/65h5C0fAEXAEHAFHINci4MSfa2+dT9wRcAQcAUfAEcg6Ak78WcfMWzgCjoAj4Ag4ArkWASf+XHvrfOKOgCPgCDgCjkDWEXDizzpm3sIRcAQcAUfAEci1CDjx59pb5xN3BBwBR8ARcASyjoATf9Yx8xaOgCPgCDgCjkCuRcCJP9feOp+4I+AIOAKOgCOQdQSc+LOOmbf4BxFIlDHOXwbzD94AH8oRcAT+3yHgxP//7pb+/7ogI/mPP/5Eli1bFr84zyMfh8J3HAFHwBHIEgJO/FmCyyvvCQJo71kpobbfv38/yZMnj/Tp01c+//zzeDdZ7VMka3OID+Q7exWBRPcx0bG9OgnvPHMI+Fcoczjtw7X+E8SfmR+QzNRJ7z7SPrt9hO3C/fTGS3Qus20zWy/RGBzLevvYu+Qzq6VbPcb566+/GFHuuedeOeaY46VAgUJSu3YdeeSRR3R6VjetuUaP02fW5x/tJfHn3NZv4qtIfDQ93Oycbbkn/GUGD2tjWxvdPmemD2uzp1sbMzP9ZKVuZvrLSp20MEnreFb6zrAupP93+rWi9z6r88pq/fRn42cTIfCfIP5EF+7H0kcgoy9fRufT7z1zZ//8808l/r//hvxFdu36VVasWClDhw6VY445RubNm5f1V8fmUm3ln8A7c3clcS3mtydzRMDbk/aJZ5W9o5mZR2bqZG90b+UI7H0EchXx82VDmly7dq288cabsuWdrbJ1yzbZvPkdfZf4Bx98EEeMup999pm8+uqrsmnTJuE94ytXrpRVq1bJjz/+qPv0s2XLFtm4YaN8/9332jb8Qtt469evlzfeeEP7oJ/ly5fLu+++qz9UW7du0THefnuz9mXn2WKSjo3/trzzzhbZsmWrEtfGjW/H52k73377bVI/1H1H3nrrLVm3bp2sWLFC1qxZI9u2bNNrZa6rVqyS1atW6x9z27Bhg3z55Zc6H/D5+quvFZMt72yRdza/I2tWr5FXlr0ir736mn5mLCu7/075g801Gwa//vqrLFmyRK677jqZNm2azJ8/X/HbtWtXvA7Yco2bN2+WrVu3Kgbgw3HKL7/8IjNmXC+vvfq6rF+3XlavWiOrVq4RMOD+gcvaNevi17Nhw0a93okTJ8rOnTu1D67p779TMjb3bc6cufLXX39qHZuzfsjg37fffas4bN+6Xd7ZvEXWrV0vr7++XJYte0WWL39DuJeff/5Fil6iWsy333yreDLfrVu2ClivX8v1cV/WyJpVa2XD+o2yedNm+fmnX1L0FWLMia+++kqef/55FWSmT58uV199tdx6660a08AzDd5GjNR95ZVXhPvOmPxt3LBB637xRco52zg///yzPrM8Rzxb/NGemAmem7SKYcq1U3777bcUz8Mdd9yh3yP6t/LSSy/LzJk3KYarV6+RVWCxZm3yXNdvlNUrV8f/wO7BBx+UOXPm6DPFd5Q/7i/z3Lhxoz5ffJcpNqf3339fcXj77bf1e/Xmm2/qNXH+m2++0bbbtm2TLXZ/X31dlr20TN5Y/qa8vWlzqus2rOw6vv/+ex2X7yBz4dnm9wLMvvn2m9hc0nAb8ftC/W3bYt8HruG1116Tl19+Wbf0+fHHH8vfu5NVZ8Y3nOkcrPmNW7lyVdJvxxbZtOltefnlZfLRRx/ZNFNsrQ++e+HvFXP5/fffU9SNfmDsn376SfHmu8yzwpy//fY7xXz9+nX6DIHnVr63m7fI66+/Llu2vKNdffjhh/LSSy/p955jYMZ10gf9ZqYwfyvLXn5FPvjgQ/uYYvvHH3/o79Cq1WATe0ZC9x+Vw754Dvh+wxPMi+/4xo2x3yfrOKzPb9ayl16RObPnyrSrpst1M66TR/+3WD4M5hPWtz5y0zZXEb/9+N5yyy1y4oknSpWKVaValepSq0Zt6dChgz544U3nx+2iiy6SWrVqSYUKFaRx48bCDys/dsOHD5fDDjtMKhxSQQ7Y7yDpcUnPuPuXcWwsbjDjnXrqqVKxYkWpXLmynHZaC3nyySfUBP2//z0sZ57ZRqpXqyVVq1aXypWryimnnCr33nuvrFu3Vs47r4NUqVJNKlWqIlUqV5Njj20q8+ffmeIZYQwEiQsuuEBq1KghBxxwgJx88sn6Yzhp0iRp1KiRVK5YRa+1/uEN5IzTW0qL5mfIac1bSIMGDaR48eJy5ZVXxvt8/PHHpfkpp0n1qjWkSqWq+nfqyc2l1RmtpU6tQ+WwOnVlQL+B+kNCo7//Sv7C2QPNF79p06ZSu3ZtueSSS6Rfv35Sv359KVy4sGJogy1YsEBatmwpVatWjf+ddtppKiRQhx+E/crtLwcdcLCcfmoLnTvzr3fYEVKlUjWd40knNNO5tTjtDDm6yTF6PUcddZSEhGLjWZ+tW7eRhg0by3fffaenbN5hvei+1Xn++ReEsapXqaGYVjyksjRq1ERatjpTWrZsLSeccJLUrXu4nHFGK7nttttSkIQ9F++/97707tlH8QTjapWry3HHHB+/juYnnyY1qtWU/csfIC+9+HJ8KjYHDrz33nsybNgwqVmzpnC9nTp10s89e/aUk046ScqWLSsHHnig3HjjjfH2EN0l3S+RI488UipVqKwYHnH4EXLxxRcL58LCXCk87yNHjtTnn2e4UqVKcvjhh+t9NQEtnFfYh+3zPBx//PH6Xerevbv06dMn/jzwjFpBaCEWo1Gjo+T0089QDMGzRvWaUrVSNTm87hFJz0ArAaPatWpr/ZkzZ2oXfD+x5th37dBDDxXGg0QoWH+YKyRz7rnnSrVq1aVChYpy3HHHyc0336x1eP75/lSrVk2qVa2uOB3V+Ghp3fJMObNVGznh+BOl7mF1pVWrVnLXXXfJ119/re3o13CAmPv37y8NjmwglStVliqVq0r9+g30urlvu2W3/J2GzRvlol27dlKzRk2dA7899erVkzPOOENat24tzZo108/cY4RqhBgKY9s9+/HHn2T8ZZfr7wW/Hfyu1KlzmHTu3EVJPayrjRWbmHsFoZHvYJUqVeSQQw7R3znIP6Ny++23Sbly5eSQQyrqs8I91mvdvVs4x/z5veVZZ8vn++9fpPNGGO3YsaMcdlhd/a2rVInvVCPFMD3h0uZkuPP5lnm3SskSJWXOrLl6OjzHgV9/+1UmTJggDRs2lIMPPlh/L1u1ai2//BwTsMHQvqfUf+SRR4XfC3CsWLGynHBCM7n11tu17+g/fs8aHtlIDq9XX7p0Pl+GDh0m7dq1l0MOriAHHXSwDBgwIH6/bJxoH7nhc64i/vBhR5s45MAK+qPR4vQzVEIGcOqE9TjGzeLH6Omnn47fE+ogvVetUlWKFS4uRQoVk9uCh8H6sC8i2lS9enWlzqGHxong77//0P6Q8E9oepKOAflv27Y9Pg6S9tDBwyRvnnySL28BmXHt9XoOTZti47DPF4Qfen4YTMPhOJpV4YJFJF+e/DJ54mRBY//yi6/kqy++Vm2fH5Dzzz8/1p/E/OIQU6MjG+ucmjQ6SnZ+uFN+/ulnWfrsUqlds44er1m9lrz15gptF/775JNPhB9ciIcffCtI1ccee6z+qBounOOH8+ijj066/qqyfXvy9d9+2+1SpVIVefbpZ+WLz79Ua8TXX38jPbv31PqQ18q3Vuo1ff3l17J16zY5++yz9UfZxo1uZ8+erW2LFSshjz+OAJZSwo/WT/F5N+Txt2zbul3qHXa45MmTV3FCK/j5l5/lhx9+0C/2Qw89FL8mSPLRRx/VbtDS/v4rWVPr2b2XzmX/cgfIc0ufk+++/U6++vIrtfa88MKLSrL8EFvhflOIUeCHOW/evAJxRjUWtJp77rlHChQooMRHG9pa+xuunykF8hWU/HkKyORJk637+HkO2A+TtWEe9Md3YczYMfE2Vi9+IGnH2iG8IQAikEafB4TDFi1aaAusEhBOly5dVEvFOsGzitbHDyfjXnJRd/nm62/0OeB54Du53/77yX333Rcf/qmnnpKSJUtq/W7dusWPx+b5l/z9d8zKg1Z81llnS7HiJVUDpCJ1mAdEV69e7P5C2Dt27JBfftkl33//g7z77nty36L7pHGjo3SMI+s3lCcefzI+jl03B6ZNn6bPSIG8BeXaq2fE6/y1+w/5e3fMBRU/mLTDHPguI2RwzQiGK95aqdavH7//UT7e+Yk888yz0qZ10vkqVWTuvBjJ0YVad5J+H55+8hkpWaK09nPhBRfp9cXrBBoyx8L7yHcS5ShfvnxSuHAhuf/++5Nml3Jj14pb7cwzz9RxSpYsLU88EcNj927wjFkLPvpopxxet77igQBnVrG//or9DtLX4CFD9XzhIkXk9tsTk2vKGcQ+MXcK3wOERH1Wul0Sr2rzjB8QkU0bNkmDI46UQgULS8H8heSy8ZfpaerSH1vmT8Hq0Lx5C9l//wPjv88hfLt2/SJ9+/bVcdu0aSM7drwbDqXWHgRS5nXEEUfIipWx303uVW4suYr4AdgegC+//EpvOj/cvXr2ToF97IYna7GYEvnRp2P7GAAAIABJREFUCgnJGnTq2En4UpcqXloOOegQFQb0HM13J4/HMawK7dudY01ld/DFRzrkoTjmmGMFaT0skErVSlWlYL6Cct45HWJf3uTpxa/piSeekNKlS6uJkfb2ZVi6dKmUK1NeihQqIrfdelvYte5zvnPnzvqDEZ5Ew0HgOPmkU+TnJGmY808/9YxAVGDXtk27VGbA66+/Xq8FLd+K4Y65kh97zKlWOAdZc/0nND1BXSl2Dk0zJD47PnrUaJ0b1ofPP02O0uc8Y6Bt2Jgcs31+oNDUChYoJEUKF5ORI0dbl1na0l+bM2Nz5gc6UeHHok/fPnpdpUqWkrvuvCtVtRuuv0EFMn7cMVtHy+Qpk5XYw+MIEWVKl9HrT4RNWPfSSy9VzcqOGQ5Lnl0qpUuWkeJFSsgD9z9gp1NtrT4nnnvuOSVUfigxY1qxH0n7bFt7/m688SbFYNDAQXYqvn3hhRdUUEVQwWrFdyR0JVER0q1Zs5bkyZNPhgwZFm9rO6NGjZIHHki+BkzNaIx58+SVKVOmWLWkZyDpi5l09Morp0mN6rVSWX6YO0IIzyTaf4iDdYiQd3G3i7VO2dLl5IH7H9RT1LX6CxcskGJFikmJYqXkoQceip1P0vetjvUX3Q7sP1D7RrBAOUhUpkyeqteZv0ABmTw5dq3M3bDHXVTh4Ir6jBmxWT+Jxg+P9erdS/suUrionHvOufE+rT1bi59BYy9dqqyUKlFGqlapLtu37dBq9Gfk+duvv8npzVvoc3vKyc2DbpLvyezZc6RQwSJq5cOyltli816wYKEKtMyjdo06ggJDsfPR/saNHa/Y8F3gt/N+e4747caNGbgIx4+fIE2aHC1//JHSPYggP3TIML1XWI54LhIVnm8UIp6pw+sdIR9+mNjlkqjtvnYs1xG/AYgG3rhhTKNF60qv4D/FvJmI+C+84ELBfI7bAKkRczY3WEtAznzu2aOndO0c06yj43Xp1FWJFKkw+sNH3X69+0mhvAVl//0OUN9d2N4ean40MS9bsS//U08/LeXKlJMihQrL3Dlz7HR8i9SJmTeUPtlv2aKVzglT+ndJMQw0IgagccMmakU4rHbdVL60Xr1iWmzXLsnXan2jZeGDxe9sBTI+66yz9AuBGTU0v6P5QApcy19JQXq0w9WCUHJo7cPkow9SfoGILcC3bddPfcMIKw1mWlwCRQoVleOPPT7+RbU6Nq/0tlhizmwd03DOOvMsnWNY3/r64ccfpOnxTXWuFQ+ppPEgYb1Zs2dL/rwF1BVD/AWFtjZ3fMU8d9Yf/tnDDq2rWJ17znnx41Y/7Jt9nkWCGcEkLEuWLJVSpWLEf/99ibW5sD77zzzzjBI/AuSNM2dFT6f6jDmbMizpR/HiQAOz+fI8EI/CPeaZQMuncL12zfhha9SoqT/QAwcO1vNWhy3PCH9WNm7aKJUqVpZ8efPLtddea4cTbufMnif169WXH39ISazMBfccwsaJJ56UAr9wbnxXjz3m+CThrYq8vSnmLrG533Xn3VK0UHEpWbyk3LcwczjbRPv0immQDeofGcfFztn3CQsSLp4C+QtIyeKl5MknntIqhu/qNavVWsIzhhCYlYKb8/B6h8sB+x2orraVK1al6BvNBlLnWrt06Sr1j2gkhxxQSX8LiYOIFlxvuBDB9OSTTk7xe2N1b5x5k/6ulC+7nzz7zBI7nOkt7k6UgYMPrCBFCxeT+bendItGO7r8siu0fq0atdQNiUuE2AjKX3/+JbuxziX9jl9z9TVyUtOTBAEmLE8+/pQUK1Jc571w4cL4KXsG2Nr9uOnGWVo3X54C0q9v//gzHm+US3ZyHfHbzeCHokmjJvoDmhnix6yK5kGxPthv3669mvDwKyHZFyiQX0455ZRUX1Tq9uvbT3r1SGld0A5FJEb8aPzHJBMfEnWSPQlTd6kSpSV/voIyZsxYaxbfQtzly5eXhx/+X/yYzRNzaEzjL5qK+DHL44+MFiX+M1orYZ3UtJl8/12yFEsg4/HHnSCF8heSOnUOTRUsZKR8wP4HysMPPxztOv7Z5sdYbc9uq2M1Pf6E+PXbl4UG7IefbYwo8VuftAn3bdBBgwfJwAED5bZbbpdCBQpLyRKl5OlnYi6cRPWtXXQL8bduZcR/dlwLiNbj853z75SSxUopwfftk2wF4dysWbNUQyEGIyR+5gLhmfZg137F5RO1Pj/yDyZpkHYuOrZhhuUB4SosSvyly0jxoiXUbB2eS2sf4i9VqpQKTGjxGRXDE60Kl8LBBx6SQjO38/QT3Q8/p0X8idpxjLiDShUqKU4ZEf+9d98rDes3yoD4m6UgfrtuI98Z116nP/p8N8eOTvndVOIvjMZfUhYtTHZHWB/pbfv0juWeOLL+kfL11zGByOpzb238555/TsqXK6/P89lntVXCsnqrVycRf76CMm5c1oj/nPbnyGXjJ6iQjJZqllHuDX/23BGk16BBQ5kz62Y5oNyBUvmQKvL227GgPZsHW1yFED8Ce7MTm8XnH9aBGBHIy5WB+J8NT2W4T/AkbrWlS55TxQSLZLcLL0q33bDBw2Vg/0HyyP8elbJly6ny1qB+w7j1za6RTgjSO+3U01MI+Qisbc9qrwpS3UPrxQOK0xr0vXff15gyhJKqlasm5JS02u5Lx3Md8Rt4EH+jhjHi79UjWeMPf3CsLhp/WsSPiXrKlKladdjQYVKwQEH9a9e2fSqTfZ/efQQpPlGJE//RR8eJj3o2HzQQHjr89ASPhBoO9Yhib9KkSapYBc49/fSzSvz4+SGhsIwdO1ajwcNj7IfEz5c01Ijef/d9Darjx6Br166pvsD4pkuVLC0lipeUgw48WCNbsRJYIcLefjw4BimBI6ZZiB8tl2J1wq31kRbxR9tZfbZgRkDmk08+qZHFBGXmz5dfRo0cFVbL1L5q/EnEf3abtvJnkvkvUWOi/KtWrqY/aEc2aJhCKIT4TeN/7933UjQn2IlVGVbwMZ90YjP9gcc1sGlTzEIQ/jhZXbYct+fHMLTzS5Y8p6bZrBI/5lB+tG7KjMafJLQuXbJUn4VixYrLQQceJFdNvSoFBjY329ocbZsR8UfbKfFXrKxCckbEf9+i++XIIxrKD98nC7aMaxp/3rxo/KmJPxyTVSWHHFRB72/jhkelEJIhfuJ/skP8vXvhJsorDRs0jAcQGiZsmQPlk08/USsW9xIB0qwOnFtjxJ9FjR9LTPPmzWXx4sWCVsw8sKLgRqGEz1z79ufIkCHDdcVDyaKlpMJBFWXj+pRR77RJJv680uzExBo/xF+4YFEpr8SfscZvViX6nzB+gsZssI91FQGjVvXaGpPBMcOLfStDBg2V7hf30I/XX3+DFC1cUl23JzY9Ka4QmatixrUzNMAzvHbw4LuIEnFa89M1zsf6TrTldxXXIPeqeLES8diURHNL1H5fOZariR9ztUqyAfEnAhbiJxrfNP6wTtu2beWKK67QQ5hTO53XWR+CgvkKSY/uPVL4v/E79+nVJ2we348Tf6DxczL2AxOrRpRq4UJFpXChwjJ//h3xtpjG8R3NmBELHrKHyLZK/GX30ziEC8/vJjfPuzm+9IvoZ1YQREuM+FvFNP4TmsVN8/xAEtEPbscec6wG00XbMu7Y0ZeqxsUDjgQP1vfcfW/8yxd+eVISf9MUgk+0b/ucHvFbneiW5YRER1u8Qtuz2+kPGtH00R/+aNvo55ipPxZclRHxf/rJp9KwQSP1p/PjyfJJK7NumqXPC35YfrjmzbtZo8u5PoQUlnBaef+9D9S1gVkRzSaRpcbqZrRF48cny/1ZtChzmmio8WeG+G0O3Otx48ZJgQIFdTyCYRFeiYi3Z9TqJtqmR/yJ6icTf4EMTf2LFi6SBoc3SHX/jfjz5MmfytQfHZNg0wZHNFQTbsxyk0x6xHUULVRUzfBZ1vjV1J9XEBZt5UB0bD7z/WlzZhsVyLifjz6yOF5tTZKpH7fHpZemtEbEKyXYQfjGX/3ss8/qkkZW1dAH8RQUu2+sQMA8vn37Dl2eWqJICTmg/EGyamXMLRB2nUz8aPw5RPxJws+vu36VY5ocKzfPvUWHxORepHBh/e2Zf8f8cBop9gmcvujCi/UYXQ0fNlL47c6fr4DGAn3zTfLS5WuvnaGrbsLfLgJycUsgDLc7u30qy1qKwZI+DBk0ROdVpHARmTo1pjQmqrcvH/tPEr899NwYiB9t2wqaLQ91ofyFpVDBQjJ6dLI2GSP+DDT+CPHTr433LmaimnVUM+5w3nk2pCxatEiXSdk6bKtv2xjxl1etHwJq27a9LiEkkr5gwYK6DjreWdKOEn+LVlK0UDFdetOhQ0fp2vV8aXrsCUpUkL9FkofLkkw6JgBm6pQr1T+IBM+PPX3x0P/+RyzK1+b3TxH/Oeeco7EBdq03z71ZihQsKqVLlJEnHotF99u5jLZZIf4vPieepIkSPz+grJG2gsYPMeBHRZtv2/YcYWkRLpSqVWvIjh3JVoD16zZI1YrVtJ8GDY4Uu9/Wl+Fpn9Pb/pPEzzy4x1dddZUGhSIIQlAFCxaSgYMGxq1Uac0328SfN2Piv2/RnhM/ri+ER67pwP0Pkddfez1+KTHiL7JXiZ/B8G0TFFe0SDFZuGBRfPzsEj/fbZa7LVm6VPvq3KGzCvssHQ3znXTu3FU6dOikdZY8+6xA/Afud7CsWrk6Pgfb2ZvE//hjTwirjD77NJavAUGpQYPYCoJuFyav7LC52DYkfo7t+vVX4Zry588vBfMXkAu6nh9X3q695tpUxI9FpGzpsvr7hpWX5zyjcsVlE9U1VLRwURk+LHWwakbt94XzuZv4G8WC+9LyuxvARB6j8VtwX/gDG2r8Vp/o7Hp1D4/f3Jk3xNYYs64X812i0rlTF9U+jz362HQ13iGDh+gSLkymJHuhsA5+xIgRqbq1eT799DNxU/+8ObG1ylSGvFjLTPKTaDGNv2CBQrr6AW394osvkbx58iuBjxgWG48x0ksksuKtFcIXArNWmVJl1Qpw/XVJSxKTpPU///xL8E1imiMQzoL7onMKP2dW4zfpfPu27XLg/gdJ40ZN9DoINCNosUzJMip9Y/KzYrjZ50TbKPFbpG+iuvwYYU5G+MHkH66XNx9/pUMqy6YgKQjJhwgqW5V0j+l329ZtUqtaLSlepKQcWucwzXHAceZrfzt3fiwvvviS8IP/7o53BZ/i+vUbNFmNuVBog/md+5E1jf9pKW0+/pnp+/htPrY1XFiWxrrm4sVL6MqE/Hnzy9VXX2OnE26zSvwkvMGykj9vQZk+bXrKPiMBtyzLq3/4kWlq/DzvCGTR4Eg6NTMzywsbcn8LFVezb2hqjwX37YnGnydNjR9sKXxX253dTq2BuBTCpYUk38INocF9YzPv4yeIlBwfL78UyyHB81K6VBm12tjyT57jypWraHIb5oFPvkTRkprXhCRh0bI3iX/wwCEaA4X2ftGFF8n5XS9QtwerKapXQ4BOjs8y3JgfxM/KjLAQYNrspJN1mR9xTCOHj9TTLIFteUarFG6Op558SljRwXWrqT9IRhX2GduP3a8J4y9XbmC1hLmJU9fdt4/kWuJHWyKJCSZrzN/pFbLPkRgnUcYrEm2YqZ8+jGhee+11TfxBRG+Z0mXlkUcfUTNZxsR/XLrE9+KLL0qZMmXU7DZ54hTNWkcSkpBM7FrsAQ+D+8wUZnWQWFkGGC0x4m+twgjL+Sj4sbFmsHqhXNnygkBEiWbFix1LXqtOXzNmXKfCh5qp6x4hn32WvAQvRvzt9irxE5HLDwCBWNOunC7TrpwmV0+/RgM8CxcsLEc1PibumzXc9OLS+JcV4if7YfXK1aVIwSJy9FHHCJn/rBjxR32znCc5iyXI4TOaJYIhGMYsB7HoY+Zrz91bb62Qiy66RHMI1KhRS32cNWvU0gRKn376qQ2bIfErBknEYo2eeQbijwlKRF+nV8I5UY/5Ga6x52GGrjRhOWH9IxqkilkJ+84e8VcRIqejwXY2B+t/7px5cmT9RqmSPZmpn5iajIgfga3SwVWkSP6i0rTpCbre3vqPEX+xPdD48wjL+RKZ+u1aWA9/xOEN1Nxco1ot2bE9eQ15SuIfZ9PKcEvinbp168aTmuHzb3F6C/09YA3+jz/8JEOGDJE2ZyUvZV3y7BKNZcD0/eqyV1ONkRPEb9dM57aPdYIgX37H+X5fOeUqufaaGfqZZXpYGm+/NeYapY21o4+oxv9XksbOd5Y8HVinihYuLjwn8+beLK1btY5/12hPDEWFgyvo/T20Tt0MgvtixE8wIf2WKF5KHnooFowdnVcq8PaxA7mO+O2ms46cbGf58uXXLGy//5Z2SkoSvuBDDzUmuw8sQwtN/eEP3MMPPqxkh/mtZs0aUu/wejJieGrNnL6SNf70iZ8vYKtWLQVN6fhjT5Bz258nFwZJSmxebO1aQ+KfO3teWEX3Ez10MeKP+fhPbJq8nO+pJ55W03jBAoV0uRPpKcNCFjFWClDogz8rZKpDaIC03nprpR2WvUn8DELkLYmDBg9OXgpmg0+dMkUKFSgkJYuXlsWPPqaHDTerk2iLuyKzUf0slyMKnwRMpj1YnyHxW1S/nWNrhG7H+vXuq1YTyP/6627Qw8w3fO7YJygQ3yuC7TntU6/BVo2/ZEzjR+uNlvC+2Rzw8WeV+CEQEvjYHK0vxuMHkKAolqiGiX2ic8kq8aPdsTwLbR3tL70yZPBQOaVZ8/h3xeoa8WOFSpP4kwSj2bNmS9GCxdQ3TIrWsOQI8R+RMiDU+rfnlHTWZHhE0OF3JJTXskv8pKYl6RLps60QC4KFCEsRVlLWopvwTx3iAUoULyFlS5dPkW3S2ucE8YfPj+2TGRVhY+dHKVcnEYSMQI21o0vnrjaNFPd6yKBkHz8Vdgerh1DeyNRXtEhxqVyhihxz1LHS4bykPCpJvbFE8ZRmp6gGj5BhvyHxwSI7/Bad0aKlBhDWrFE7rkxyL+1+Rprskx9zHfEbihoQ06aNRnXXrFZLTaJ2LnoTzjvvPE0sYufDLUk+SP8YlvAGYuYvVqSolClVRqXl0SOTM56FbWwdP75CsrclKtYvGa0QJsqUKqeEQgIeSnTe9sUw4sfXHtX4rU/aP/bYY/EHMUb8Scv5gnX89NmxQ0ddN4ypauYNyelg6YMAQ9K/hvMxv/9zS59XbRV/dmjCTib+WFR/pkz9I5LX8ZNV0IphEF4XP05FixbVdehWz7aYMsuXLa8CCUk4MirWL8Rv6/hJ32uCY3T8P//8Q1q1JB9CHjlUcx4kvw+CsXCzxKL6idIP1oAHJumffv5Z4zD40WB51oH7H6iE2aTxUfGcD7F5Jf948IN0/PFNddy+fVMuIWRc7kXM1F8yvpzPrk23vKvik8+EWAB7jjS4L8k1kpHGbzgSVR99Hqw/kgih8ZOSmaVYaZV33tms6Wsh4UGDhqRVLX6c5+eoxkcpruRrsOQ3dm9sfAjyuGOPl3Hjxsfb2s4vu35RwVaJ/6STU8Qh0I/1gQuApDTc3yPq1RdcLRTD8u677lZNnOWcixakFLCsjo0Z3cbW8edN0vhTLucL2/bv20/y5skj+5ffT7Mc0o9Z4bJL/NwPrJzhfUHxAU+WFWMJwT0XZqGE+EuWLCVlSpZNuAafoNrmp7KOP68KU6FwadceRvUjnFK4VvvjM4Igls9Y2S0tz2gp553bIekjmXeSTolo3hQEIpbOIcxQ7N6xD8adOnRObpC0Z/g++NDDUrZM+Zjgnie/dOrYOX5vrQ7B0cRzsWqqc8cu8b5szrblBPn+yfnC8zImsvQz3jAX7ORK4rcbRg5zlnMhxU6ZlJzhK8QdTWS//faLv8Y1vInUI90tJi8r1ndYDy0fTZe/MSOTI2utLm3P73KBPgzHHn2cLnvhWHje+mdLNHe9w+pp5KmuK/09OeVlWM8ecDKuGbmZlhjWY59Ic4J57MvBMTL36Zf0hGYpTKHrN6yXihUrKfkgUa9bE8uDThvW7ZMulbW9Vmwezy99QV0UBBiGmfuoR0ZDvgxk7vvp51jmwhBD6oR4gCk/PrxP4MOkBD52PtqO2ArcOmadCM//umuXtGzRUvsiH/tPP8VeGMOcrT+7DrZ2LfxoofFDDNwzoooTlcmTJul1Hbj/wfLUk7F8AdYH9THnF8hXQA7a/2DZsC452j/si+j3ZiedlCLIqEC+QqrRkgs8nKfts3YfUgPTfv0HxLuzsTHLqhm0cDG5M0FGQRqQM6BHsOIFAZP0r/zAzU3K3BdiGR8k2CF3eYkSJZIzWgb3kQyQRIqD+3ffpxZ27VqIrSFvPfd70MDk75pdSzBcfHdIUpprSOrO+akzJlLxscWPq9ARCqE2JkIWy9kY86gmx8RXgsQHYGe36OoVMMaPbmTEvGxu996zQM26WHwefsBybCQLaCn6i3wggJbxK1eqoimEI6f1I+m4C+TPL8WLFJU7ghS3Rsi8TKbiwZW0n/GXJgs4Nr+wz/Be8v3lHQG2fM/qXXP1tfq953oef+xxPWyYvfDii5oXA3/308GzbmPpEkFN4JNXTm4Wcx/SgZ1nf/asOdp/2VLldD2+jRtuL7ro4rh7de3adZpxz1I221ys/h23zZfiRUuqv/6WW2LxTXx3rR4poBNl3rTz9IPyhrm/UIEiaj2zAD6bN88KqaF5DsqULCeP/i+Wnpu29BP2NXDAYK1HbpQwWZXNN7dscyXxG7iQT0wCzaMJVm6aeZP60vDf8sPJDx0vj0Fj4eZGbyJZ0Vjfz/p5i7C2m8zWHhAeeEvJO6h/ctpSq4v/Dk2fBwciNc2PB8vq2ENkc7dsaNdZ7v7IA2b1mMPcuXP1xwfBA0GBLzN+Mf4wy5PNjmsg8ZA9zJ8kLUGD+ElpagFLNp+FCxep5M+cmzQ+Wt+mxpi8La9IkWJSq1ZtzdBn8wCfWNauPLLgngV62Pr65NNPpXFjcvXn1ZeZEJxFSev60eBiKX7zKXktffa5VPfG2qIhk3SGFRVWGNf+OMYyOq6D3PU33TRLCTY8b+3YGj64NA6tfagUzF9Y/ZqzbpylsRlo2txPfjhZh0+/xxx9jLz80jLthpTi1gfmZKKxER4weQ8fOkLN4nZvCPAjFe1+5feL5xG3OZD3vXxZ0ibnkfPPvzBV5kUEuGrVauh51qGHWi/P9/RpV+v18kyAJbnpeb+DPRMIcOXL7Sd33x1b6gkes2bNUeEVMhoxfGQ8kQnnosWOoTGS7x2zcZiTgPcRkBmS3A333HVPtHn8/vAjTYxNubLlNOMbaZItpbWNYY35bMfwc5NRE3wOPqiCrnxBY/3jj9/l+x++VysHLqcrJiSvyKEfa893m+WU4FOmdDm59dbb1NWH8MgPNm+UbNs2thz0hKYnyvLXYyZx2hPsypa5T518pd5fnq1pV14dd33ZODb36Ja8GS1btI7fI7IvMi7jky2Qlw6REpvo80Nr15GHH4ylA473k3RLMD2XLBbL1d+1c9d4kKI9g/H6wbPNvC3tNu+ECOuSihezOtYmE9DpAwvDHbfP19VMPM/Tr5wez21h14oAV6f2Yfo9r3tYvRTBqfTB9wH3D8mewJ2lz6wgsOeS7wPfzzJlystrry3X+t2795TChYvqWwHpw8ay69q4fqOumOE5QJCz32nOk9cDC0a1KjXkvaQXHVk7+rHrZn/0iDH6LBHcx+85JazDs0WMAeOgZCGIcD1WuGdjxlyq509pdqouf+Rc7L0Rqb8/1m5f3eZq4gfUTz7+RDNSHXjgQbq8iC875vsTTjhBv/isP7aI3vCh4saSw7t69er6Bi3eNMWyurBQ39rwpSWdL5n+wsIPLC+3qFWzttSqWUuqV6+hBIzfKlGx/h584EElBMxeFDse7vNyEyRRYhnot07tOirI8JbB008/Xf8ge+IXeEMf/mYKL+RgpYDNCZMfmPD++rAwd/omQrtu3Xp6nuh2orR56xVWAV640qNHDxUsDq1zqNxzd8ofeXs7H7nYuf4a1WNj3XlnykRDjKuENX26tG/fXu8N86perbq+zZAXKVnkLnUR1HgVMJkQ0Vx4MxzJiixOw/CaN3euHH/c8doPfbHOn/lanEJ4vbYPGfNiGcavU6eOVKlcRa8X6w8kyrOAIMU7Ae65++74K5utPVs0NQQDxiP4jrfMVa1aTefJvaF/XpLC3HlDGuulKfZjxD6vXOWH7+CDK+j9bdXqTOnZs5f+cd3cg4YNG6lwYStSSJeMsNG4USPFunbtOiq8ch/tmeC5Jr8Db0rjR5cfLVZRNGlylOLEPWpQv4EKxGFOAp1g0j/w5Y97xlpl5sJ1cM2kdGYpKWNjCo8WuzdcM/eCZ5TvGeMyJ+4/cTdWL9rePiPgnnfueZrVrmjRYnLkkQ2k+WnNdX06aZtJ2JKo4Eqz+4vAQuR6hYoV9fvOKh7uL98hXsbCevEwuZX1B0lBzI0bNY4/W40aNZbevXonXB1EO7seXCqMU7tWHV2mS/AuL99iXT0xRbyhj/sFLlgtw2fV+kBxueyyy/TZBjcsJjxr4G/LSa2uzZktgh9CBhYyVjJxn6Lfm7PPbpvibZ4IlZdeOk7fpkdqZX5reD54ac3Oj2NuON4poZgyl5o19Y/P9vIf3JHnnnue1D+ivn6v+D3gBWh8b6nHH98vrK+8WAm3QqdOnfUdDtRlqa7FG9h1EeiKW5LfHeaFEgf5k8Br+fLX9TcOXBiHF5uFq5usD8Nm165fNbCP+x7lA6vLs86bU/nuk0WV+fL8kvqYe8dvxVVXTYv/HkRfaW5j5YZtriZ+JFsrECgPBD/IkC5vV4vn3E8KVKMuN5k/XpzDjyg/qOyjzbDlh9keBOvbxsFEvmTpkngf1KM97wKnLfv80S/R3LSL9mVzQFolsZD1bWPZeebBDwKaJ31t3xHrm3H4zCuH7Y8fSFYFoE3QH9pibE5bU8wJTZxcZOjsAAAD3UlEQVR+w2uEFJgv7gRe1AHhUpDUiRlAWOALtfixxfLVV8n51K0fcGcsNE67fn7wmU/02rFe4HoB67A+18F1Mhfa8Mc80Ir44z4yd/pFCue8jc9x+kRoYHzGZT6WKjeKK23BkPzybHfs2C6b39mscwIDfnyYX/hjHPbBPmODOeOAtV031wSR2n1hSz2Oo2XYtbENC35lXmhy9933yNy5N8stt9yq2NPeosHtevlhJ2Br8+a3UzwT4EB98GLLM0JgHgUrBnOlDtfLfJkX/fAc2rzCObEfzpPngdfd8ixggWLftK+wHu2YK8dYhYDwCib2/IIFc2GOaY0bjo32Td3HHlusr0iGgFjJEt6fcHz2uXbuod0XrnXFirf0Gcecz/OeUfIkBEwIlr4MM54tnlMsjWnNneNYk2hrzzjvp+fZ5dniO8/1c2/AKa3C88I8uZ92HfTH+Fw7baO/HYyNwMC1M1e+N2DP2Pw22Hgc57my+2RjgbPepx0pv0fU49lhPvY7x9a+x5zn+eB5emfLO/F7vW1byu8DcwFPnotPPvlYceCa7PvIqiuuwebFddKnjrkj9jvNHJg/98++w+DDcfqnbbTQJ4U58oIss/6G9cJ2fF+4f7wdk+edZw5BBeXv/0vJ1cRvD0l6N8Pq2M23z2m1sYcuPE+b8EvGPsesz7BuuJ+oL86H7cJ9a8ux8EG045nZmnsirbrM3eaVaGw7l1Z72tj8ErUP20X7yqg+ba0N27QK5/gL70miutHx+Bw9lqhdeCxRm6z2QX+0CZ+bRP2G40b37ZqjxzP6bGOmV4++E12TzTHROesv0byoz/GMSlrj0s7GTq8PGyecX7ifXls7l9X61i6tuWe1P+qHbdhPq28bmy11+AtLRvc62iYz49h8wnGi+9F5RM9n5bPNMbt9JmoXvQZwitajTrReWvOmLXVzc8nVxJ8Z4P+JGxQdI/o50TwzU8fa7UndjNqmdT7RcY4lOm7zzMltdJzwc1r7Nj7nwzp2PLrNqE54PtyP9pPe5+y2sz6z097asLV96y/RNjN1ErXLzLH0+k7vXHp9h+3C/bBNeDzcD+tktJ+T7bLSV1p1OW5/ieae3jmrn17fViejbaI+Eh3LqJ/snA+vMTtjhu2zM/7/lzb/74n//8uN8utwBBwBR8ARcARyAgEn/pxA0ftwBBwBR8ARcARyCQJO/LnkRvk0HQFHwBFwBByBnEDAiT8nUPQ+HAFHwBFwBByBXIKAE38uuVE+TUfAEXAEHAFHICcQcOLPCRS9D0fAEXAEHAFHIJcg4MSfS26UT9MRcAQcAUfAEcgJBP4P+pFog04tYY0AAAAASUVORK5CYII=)

facoltà di Scienze Politiche, Economiche e Sociali
Experimental projects of machin learning(2022- 2023)

# Topic: cats and dog (Project 2)
 
Writer: Elaheh Esfandi

Use Tensorflow 2 to train a neural network for the binary classification of cats and dogs based on images from the given dataset.

### step 0:installing the packages we need
"""

pip uninstall keras-preprocessing -y

pip install -q -U git+https://github.com/keras-team/keras-preprocessing.git

pip install -q -U keras-tuner

"""### step 1: libraries and datasets

##### step1.1:importing datasets and the libraries
"""

from zipfile import ZipFile
import keras_tuner as kt
import os
from os import listdir, makedirs
from os.path import isfile, join
import pandas as pd
from PIL import Image
import glob
from pathlib import Path
import shutil
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import KFold, StratifiedKFold
from tensorflow.keras.optimizers import SGD, RMSprop
import cv2
from os.path import isfile,join, exists
import zipfile
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import pickle
import statistics as st
from PIL import Image

# upload the data set in to my google colab
!wget https://unimibox.unimi.it/index.php/s/eNGYGSYmqynNMqF/download \
      -P /image/

# then i Open the zip file containing all the images
# opening the zip file in read mode
with ZipFile('/image/download', 'r') as zip:
    # printing all the contents of the zip file
    zip.printdir() 
    # extracting all the files
    print('Extracting all the files now...')
    zip.extractall()
    print('Done!')

"""##### step1.2: data preparation """

# Define the paths,the glob module is used to retrieve files/pathnames matching a specified pattern.
#to retrieve paths recursively from inside the directories/files and subdirectories/subfiles.
cat_path = glob.glob("./../content/CatsDogs/Cats/*****.jpg")
dog_path = glob.glob("./../content/CatsDogs/Dogs/*****.jpg")
paths = [cat_path, dog_path]

# Remove the images w/ size = 0
for path in paths:
  for filename in path:  
    if os.stat(filename).st_size==0:
      os.remove(filename)
      num_skipped = 0
total = 0
for path in paths:
  for filename in path:
    if os.path.exists(filename):
      try:
        total += 1
        fobj = open(filename, "rb")
        is_jfif = tf.compat.as_bytes("JFIF") in fobj.peek(10)
      finally:
        fobj.close()
      if not is_jfif:
        num_skipped += 1
        # Delete corrupted image
        os.remove(filename)

print("Deleted %d images" % num_skipped)

df_cat = pd.DataFrame({"file_name": [f"/content/CatsDogs/Cats/{i}" for i in os.listdir('/content/CatsDogs/Cats')]})
df_cat["label"] = "cat"
df_dog = pd.DataFrame({"file_name": [f"/content/CatsDogs/Dogs/{i}" for i in os.listdir('/content/CatsDogs/Dogs')]})
df_dog["label"] = "dog"
all_df = pd.concat([df_cat, df_dog], ignore_index=True)
all_df = all_df.sample(frac=1, random_state = 666).reset_index(drop=True)
all_df

all_df.describe()

# Split in training, validation set and test set
train_val_df, test_df = train_test_split(all_df, test_size=0.2, random_state = 666)

# Split training, validation set in training and validation set
train_df, val_df = train_test_split(train_val_df, test_size=0.2, random_state = 666)

"""Images must be transformed from JPG to RGB (or grayscale) pixel values and scaled down. Experiment with different network architectures and training parameters documenting their influence of the final predictive performance."""

image_data_generator = ImageDataGenerator(rescale=1/255.0)
validation_imagedatagenerator = ImageDataGenerator(rescale=1/255.0)

# Flow From DataFrame
train_valid_generator = image_data_generator.flow_from_dataframe(dataframe=train_val_df, 
                                                            directory=None, x_col="file_name",
                                                            y_col="label",
                                                            batch_size=64, seed=666,
                                                            shuffle=True, class_mode="binary", 
                                                            target_size=(180,180))

test_generator=image_data_generator.flow_from_dataframe(dataframe = test_df, directory=None,
                                                          x_col="file_name", y_col="label",
                                                          batch_size=64, 
                                                          seed=123, shuffle=True, class_mode="binary",
                                                          target_size=(180,180))

train_generator = image_data_generator.flow_from_dataframe(dataframe=train_df, 
                                                            directory=None, x_col="file_name",
                                                            y_col="label",
                                                            batch_size=64, seed=666,
                                                            shuffle=True, class_mode="binary", 
                                                            target_size=(180,180))

valid_generator = image_data_generator.flow_from_dataframe(dataframe= val_df, 
                                                            directory=None, x_col="file_name",
                                                            y_col="label",
                                                            batch_size=64, seed=666,
                                                            shuffle=True, class_mode="binary", 
                                                            target_size=(180,180))

"""###step3:models

#####model1 :VGG

architecture of VGG:

**input:**VGG takes in a 224x224 pixel RGB image. For the ImageNet competition, the authors cropped out the center 224x224 patch in each image to keep the input image size consistent.

**Convolutional Layers:** The convolutional layers in VGG use a very small receptive field (3x3, the smallest possible size that still captures left/right and up/down). There are also 1x1 convolution filters which act as a linear transformation of the input, which is followed by a ReLU unit. The convolution stride is fixed to 1 pixel so that the spatial resolution is preserved after convolution.

**Fully-Connected Layers:** VGG has three fully-connected layers: the first two have 4096 channels each and the third has 1000 channels, 1 for each class.

**Hidden Layers:** All of VGG’s hidden layers use ReLU (a huge innovation from AlexNet that cut training time). VGG does not generally use Local Response Normalization (LRN), as LRN increases memory consumption and training time with no particular increase in accuracy.
"""

# Model 1 Specification
def model_1_specification():
    inputs = keras.Input(shape = (180,180,3))
    
    # First block w/ 32 filters
    x = layers.Conv2D(filters = 32, kernel_size = 3, activation = "relu", padding="same")(inputs)
    x = layers.MaxPooling2D(pool_size = 2)(x)

    # Second block w/ 64 filters
    x = layers.Conv2D(filters = 64, kernel_size = 3, activation = "relu", padding="same")(x)
    x = layers.MaxPooling2D(pool_size = 2)(x)
    
    # Flatten Layer
    x = layers.Flatten()(x)
    
    # Fully Connected Layers
    x = layers.Dense(128, activation = "relu")(x)   
    outputs = layers.Dense(1, activation = "sigmoid")(x)

    model = keras.Model(inputs = inputs, outputs = outputs)
    return model

"""Before we can start with training, we have to compile the model using the compile method. Compiling configures the model for training.
I choose the "Adam" optimizer as this is an excellent default to start with. The loss function is "binary_cross_entropy" because we are training a classification model with two possible outputs. I want to report the accuracy during training; therefore, I added accuracy as a metric.
"""

# Compile
model = model_1_specification()
model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])
tensorboard = keras.callbacks.TensorBoard(log_dir="./results",)
model.summary()

"""After i compiled the model, i started training the model by calling the fit method on the model instance. the parameters are as bellow:


1. **The first parameter** is the iterator that we created by calling the flow_from_directory of the ImageDataGenerator for the training data. 
2. **The second parameter** is the iterator from the validation data.
3. **The epoch parameter** shows how many times the model will process the entire training set. Here, I want to process all 20.000 training images 50 times.
4. **The steps_per_epoch** show how many batches it should process before it finishes the epoch. i established a batch size of 200 previously on the flow_from_directory, which gives 200 * 50 = 20,000 — the number of images of our training set. The same goes for the validation_steps, 50 * 100 = 5,000, the number of images in our validation set.


"""

# Fiting the model
step_size_train = train_valid_generator.n//train_valid_generator.batch_size
step_size_validation = test_generator.n//test_generator.batch_size

history = model.fit_generator(generator= train_valid_generator,
                    steps_per_epoch=step_size_train,
                    validation_data=test_generator,
                    epochs=2,
                    validation_steps=step_size_validation
                    )

features = model.predict(test_generator)

features

features = model.predict(test_generator)

# plot the model
plt.plot(history.history['accuracy'], label='training_accuracy')
plt.plot(history.history['val_accuracy'], label = 'test_accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.ylim([0.5, 1])
plt.legend(loc='lower right')
plt.title("Model 1: Training vs Test Accuracy")

# plot the model
plt.plot(history.history['loss'], label='training_loss')
plt.plot(history.history['val_loss'], label = 'test_loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(loc='lower right')
plt.title("Model : Training vs Test Loss")

# validation
test_loss, test_acc = model.evaluate(test_generator)
print("Test Loss: "+str(test_loss))
print("Test Accuracy: "+str(test_acc))

"""#####model2 : Hyperparameter tuning

Parameters of the model are the parameters calculated on the given dataset by the model. The weights of a deep neural network, for instance.

**Hyperparameters of Models:** are the parameters where the data model cannot predict. This is used for calculating the parameters of the model, in deep neural networks is the learning rate.
"""

# Define a HyperModel class
def build_hypermodel(hp):
    inputs = keras.Input(shape = (180,180,3))
    
    data_augmentation = hp.Float("data_augmentation", min_value = 0.01, max_value = 0.1, step = 0.01)
    dropout_hidden_layer = hp.Float("dropout_hidden_layer", min_value = 0.05, max_value = 0.1, step = 0.01)
    dropout_flatten_layer = hp.Float("dropout_flatten_layer", min_value = 0.2, max_value = 0.5, step = 0.1)


    x = layers.RandomFlip("horizontal")(inputs)
    x = layers.RandomRotation(data_augmentation)(x)
    x = layers.RandomZoom(data_augmentation)(x)

    # First block w/ 32 filters
    x = layers.Conv2D(filters = hp.Int("convolution_1_filters", min_value = 16, max_value = 64, step = 16), kernel_size = 3, activation = "relu", padding="same")(x)
    x = layers.MaxPooling2D(pool_size = 2)(x)
    x = layers.Dropout(dropout_hidden_layer)(x)

    # Second block w/ 64 filters
    x = layers.Conv2D(filters = hp.Int("convolution_2_filters", min_value = 64, max_value = 128, step = 32), kernel_size = 3, activation = "relu", padding="same")(x)
    x = layers.MaxPooling2D(pool_size = 2)(x)
    x = layers.Dropout(dropout_hidden_layer)(x)

    # Third block w/ 128 filters
    x = layers.Conv2D(filters = hp.Int("convolution_3_filters", min_value = 128, max_value = 256, step = 64), kernel_size = 3, activation = "relu", padding="same")(x)
    x = layers.MaxPooling2D(pool_size = 2)(x)
    x = layers.Dropout(dropout_hidden_layer)(x)

    # Fourth block w/ 256 filters
    x = layers.Conv2D(filters = hp.Int("convolution_4_filters", min_value = 256, max_value = 512, step=128), kernel_size = 3, activation = "relu", padding="same")(x)
    x = layers.MaxPooling2D(pool_size = 2)(x)
    x = layers.Dropout(dropout_hidden_layer)(x)
    
    # Flatten Layer
    x = layers.Flatten()(x)

    x = layers.Dropout(dropout_flatten_layer)(x)

    # First Fully Connected Layers    
    x = layers.Dense(hp.Int("num_units", min_value = 64, max_value = 256, step = 64), activation = "relu")(x) 

    # Second Fully Connected Layers    
    x = layers.Dropout(dropout_flatten_layer)(x)
    x = layers.Dense(hp.Int("num_units_second_layer", min_value = 64, max_value = 256, step=64), activation="relu")(x)

    # Last Fully Connected Layer
    x = layers.Dropout(dropout_flatten_layer)(x)  
    outputs = layers.Dense(1, activation = "sigmoid")(x)

    model = keras.Model(inputs = inputs, outputs = outputs)

    model.compile(optimizer="rmsprop", loss="binary_crossentropy", metrics=["accuracy"])
    return model

model.summary()

""" The tuning technique is used to estimate the best hyperparameter combination that helps the algorithm to optimise the efficiency of the model. 
 acording to the Methods of Hyper-Parameter Tuning, **bayesian Optimization** is The optimisation challenge is to tune and locate the correct hyperparameters for your model. By adjusting model parameters, to minimise the loss function of our model. In a minimal number of moves, Bayesian optimism helps one find the minimum point. Bayesian optimization also uses a buying feature which guides the sampling in areas where the best observation is likely to improve on the present one.
"""

# Tuner
tuner = kt.BayesianOptimization(build_hypermodel, objective="val_accuracy", max_trials=3, 
                                directory="cats_dogs_run",
                                project_name="cats_dogs_classification",
                                overwrite=False)

# Summary of the search space
tuner.search_space_summary()

# Stop the training when you start overfitting
stop_early = [ keras.callbacks.EarlyStopping(monitor="val_loss", patience=4)]

# Start the search! 
tuner.search(train_generator, 
             batch_size=64, 
             epochs=2, 
             validation_data=valid_generator
             ,callbacks = stop_early)

# Get the optimal hyperparameters
best_hyperparameters = tuner.get_best_hyperparameters(num_trials=3)[0]

best_hyperparameters.values

hypermodel = tuner.hypermodel.build(best_hyperparameters)

# Train the model on the training set for 2 epochs
stop_early = [keras.callbacks.EarlyStopping(monitor="val_loss", patience=5)]
history = hypermodel.fit(train_generator, epochs=2, validation_data = valid_generator, callbacks = stop_early)

# Get the best hepoch, i.e. the epoch with highest validation accuracy
val_acc_per_epoch = history.history['val_accuracy']
best_epoch = val_acc_per_epoch.index(max(val_acc_per_epoch)) + 1
print('Best epoch: %d' % (best_epoch,))

# Re-instantiate the model w/ optimal hyperparameters
hypermodel = tuner.hypermodel.build(best_hyperparameters)

# Retrain the model on the optimal number of epochs
history = hypermodel.fit(train_valid_generator, epochs = int(best_epoch*1.2), validation_data = test_generator)

hypermodel.summary()

plt.plot(history.history['accuracy'], label='training_accuracy')
plt.plot(history.history['val_accuracy'], label = 'validation_accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')
plt.title("Training vs Validation Accuracy")

plt.plot(history.history['loss'], label='training_loss')
plt.plot(history.history['val_loss'], label = 'test_loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(loc='lower left')
plt.title("Training vs Validation Loss")

test_loss, test_acc = hypermodel.evaluate(test_generator)
print("Test Loss: "+str(test_loss))
print("Test Accuracy: "+str(test_acc))

"""## step 4: Cross-Validation

Useing 5-fold cross validation to compute the risk estimates. While the training loss can be chosen freely, the reported cross-validated estimates will be computed according to the zero-one loss.
"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten, Conv2D, MaxPooling2D
from tensorflow.keras.losses import sparse_categorical_crossentropy
from tensorflow.keras.optimizers import Adam
from sklearn.model_selection import KFold
import numpy as np

# K-fold Cross Validation model evaluation
# Define the K-fold Cross Validator
kf = KFold(n_splits = 5, shuffle = True, random_state = 123)
kf2 = KFold(n_splits = 5, shuffle = True, random_state = 123)
count = 1

# Define per-fold score containers
TEST_ACCURACY = []
TEST_LOSS = []

"""Now, let's slightly adapt the model in order to add K-fold Cross Validation:

Firstly, we'll strip off some code for the model that we no longer need.

secondly,longer generate the visualizations, and remove the part generating them
"""

for val_train_index, test_index in kf.split(all_df):
#FIRST SPLIT: train+validation set and test set
    val_train, df_test = all_df.iloc[val_train_index], all_df.iloc[test_index]
    print("\n")
    print("Cross validation split n(1,2,3,4,5)")
    train, validation = next(kf2.split(val_train))
    
#SECOND SPLIT: train set and validation set
    df_train, df_validation = val_train.iloc[train], val_train.iloc[validation]
    print("length of training set" + str(len(train)))
    print("length of validation set " + str(len(validation)))
    print("length of test set" + str(len(test_index)))
 
#data GENERATORS
    train_data_generator = image_data_generator.flow_from_dataframe(df_train, 
                                                   directory = None,
                                                   x_col = "file_name", 
                                                   y_col = "label",
                                                   class_mode = "binary", 
                                                   shuffle = True,
                                                   seed = 666,
                                                   target_size=(180,180), 
                                                  batch_size = 64)
    valid_data_generator  = image_data_generator.flow_from_dataframe(df_validation, 
                                                    directory = None, 
                                                    x_col = "file_name",
                                                    y_col = "label",
                                                    class_mode = "binary", 
                                                    shuffle = True,
                                                    seed = 666,
                                                    target_size=(180,180),
                                                   batch_size = 64)
    test_data_generator = image_data_generator.flow_from_dataframe(df_test, 
                                                  directory = None, 
                                                  seed = 666,
                                                  x_col = "file_name",
                                                  y_col = "label",
                                                  class_mode = "binary", 
                                                  shuffle = True, 
                                                  target_size=(180,180),
                                                  batch_size = 64)
    
# model
    model=model_1_specification()
    model.compile(loss='binary_crossentropy',optimizer="rmsprop", metrics=['accuracy'])    
       
# Fiting the model
    history = model.fit(train_data_generator,
                    validation_data = valid_data_generator,
                    steps_per_epoch = train_data_generator.n//train_data_generator.batch_size,
                    validation_steps = valid_data_generator.n//valid_data_generator.batch_size,
                    epochs = 2)
 # Provide scores   
    print("results evalution:")
    results = model.evaluate(test_data_generator)
    print(results)
    tf.keras.backend.clear_session()